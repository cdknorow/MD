import sys
import os
import numpy as np
import matplotlib.pyplot as plt
import MD
import MD.analysis.particle_distance as p_dist
import MD.util as util
import MD.base.points as points
import MD.plot.pyplot as pyplot
from MD.analysis.particle_distance import particle_distance
from MD.analysis.particle_distance import min_particle_distance
from MD.analysis.nearest_neighbor import nearest_neighbors_point
from MD.analysis.nearest_neighbor import nearest_neighbors_index
from MD.plot.histogram import histogram
from MD.plot.histogram import histogram_normal
from MD.analysis.rotation import single_rotation
############ 
# Run from inside a folder
#########
reload(MD)
reload(pyplot)
############################################
## returns the arrays with the drift removed
############################################
def drift_remove(VW,L):
    from MD.analysis.drift_remove import eliminate_drift
    VW = eliminate_drift(VW,L)
    return VW
    #Find the msd of the system
############################################
## returns the arrays with the drift removed
############################################
def drift_remove_all(VW,V,W,L,VW_index):
    from MD.analysis.drift_remove import eliminate_drift
    W = eliminate_drift(W,L)
    V = eliminate_drift(V,L)
    VW = eliminate_drift(VW,L,VW_index)
    return VW,V,W
    #Find the msd of the system
#########################################
# What you want to do in those directories
########################################
def end_end(V,W,M,L):
    T=M.cord_auto(['T'])
    K=M.cord_auto(['K'])
    V=M.cord_auto(['V'])
    W=M.cord_auto(['W'])
    ndna = T.shape[1]/V.shape[1]
    #K-V
    #W-T
    VK=[]
    WT=[]
    last = V.shape[0]
    #find center-ssdna particle distance
    for k in range(last-5,last):
        for i in range(V.shape[1]):
            for j in range(ndna):
                VK.append(points.dist(V[k][i],K[k][j+i*ndna],L)[0]-3)
                WT.append(points.dist(W[k][i],T[k][j+i*ndna],L)[0]-3)
    hist_K,xK,max_k=histogram(VK,10)
    hist_T,xT,max_T=histogram(WT,10)

    plt.close()
    pyplot.plot_bar(xK,hist_K,save='VK_distance')
    plt.close()
    pyplot.plot_bar(xT,hist_T,save='WT_distance')
    plt.close()

    #find the length of the polymer

    KT=M.cord_auto(['K','T'])
    S=M.cord_auto(['M'])
    edge=[]
    for k in range(last-5,last):
        for i in range(S.shape[1]):
            edge.append(points.dist(KT[k][i],S[k][i],L)[0])
    hist_edge,xedge,max_edge=histogram(edge,50)

    pyplot.plot_bar(xedge,hist_edge,save='polymer_length')
    plt.close()
############################################ ## msd
############################################
def msd(VW,L,step=1,save='MSD_time'):
    from MD.analysis.msd import msd
    #Find the msd of the system
    x,msd=msd(VW,L,step=step)
    pyplot.plot(x,msd,xlabel='Time',ylabel='msd',save=save)
############################################
## 	g(r)
############################################
def distance_distribution(V,W,L,n_frames=15,n_start=1):
    #finds end to end distances and plots a histogram with that data
    def hist(M1,M2,save_name,label):
        distance=particle_distance(M1,M2,L)
        hist_s,xs,max_hist=histogram(distance,bins=50)
        return xs,hist_s
    ########################################
    #Plot Data for AA,AB,BB distances
    save_name='_time_'+'%i'%(n_start)
    start=n_start
    finish=n_start+n_frames
    max_hist=0
    AB=hist(V[start:finish],W[start:finish],save_name,'A-B')
    AA=hist(W[start:finish],W[start:finish],save_name,'A-A')
    BB=hist(V[start:finish],V[start:finish],save_name,'B-B')
    pyplot.plot3(AA[0],AA[1],AB[0],AB[1],BB[0],BB[1],'s','g(s)',
            'A-A','A-B','B-B',save='nnplot_'+save_name,showleg=True)
############################################
# lifetime of connections
########################################
def find_lifetime(M,L,steps,temp,step_range=30,delta=4,rcut=1.0,step=5e4):
    import MD.analysis.lifetime as life
    try:
        C = util.pickle_load('C.pkl')
        G = util.pickle_load('G.pkl')
    except:
        C=M.cord_auto(['C'])
        G=M.cord_auto(['G'])
        util.pickle_dump(C,'C.pkl')
        util.pickle_dump(G,'G.pkl')
    #The total number of frames we are going to look at
    for i in steps:
        try:
            print 'Frame',i,'Temp',temp[i]
            x=np.arange(i,step_range+i,delta)
            #Find he number of connections at specific points x
            remain = life.lifetime(C[x],G[x],L)
            print remain
            pyplot.plot(x,remain,xlabel='Time',
                    ylabel='remaining connections', save='lifetime'+temp[i])
            plt.close()
        except:
            pass
######################
# FInd the solid particles in a simulation
#####################
def solid_particles_vmd(VW,V,W,L,M,skip=15,step=5e4,rcut=False):
    VW_names = M.get_names(['V','W'])
    import MD.dna_scripts.solidparticle as sp
    reload(sp)
    sp.solid_particles(VW,V,W,L,VW_names,skip=skip,step=5e4,rcut=False)
    #if os.path.exists('bcccrystals.xyz') == False:
    #    sp.solid_particles(VW,V,W,L,skip=skip,step=5e4,rcut=False)
    #sp.crystal_size(L,VW.shape[0]/skip,VW.shape[1])
#####################################################
#find number of a specified pair of particles that are within r_cut of each
#also finds the number of connections
#####################################################
def find_networks(M, VW, L, var, n_finish=1, n_start=0, delta=30, rcut=1.0):
    ndna = var['ndna']
    #The total number of frames we are going to look at
    x=np.arange(n_start,n_finish,delta)
    print len(x)
    #Find the number of connections at specific points x
    import MD.analysis.connections as con
    import MD.analysis.graph as graph
    try:
        connections = util.pickle_load('con.pkl')
    except:
        G=M.cord_auto(['G'])
        C=M.cord_auto(['C'])
        connections = con.connections(C[x],G[x],L,rcut=rcut)
        util.pickle_dump(connections,'con.pkl')
        util.pickle_dump(C,'C.pkl')
        util.pickle_dump(G,'G.pkl')
    #plot total number of connections
    print connections
    num_connections=con.num_connections(connections,VW.shape[1])
    pyplot.plot(x,num_connections,xlabel='Time',
            ylabel='hyrbid. density', save='connections')
    plt.close()
    #get the info
    networks, num_networks, deg, neighbors, num_n, gr = graph.grapher(connections,VW.shape[1],ndna)
    #plot the number of neighbors at each timesteps
    pyplot.plot(x,num_n,xlabel='Time',
            ylabel='num neighbors', save='neighbors')
    plt.close()
    print 'making plot'
    label = ['networks','1','2','3','4','5','6','7','8','9']
    pyplot.plot_multi(x,deg,label,xlabel='time',ylabel='number',save='con_net')
    return x, networks, connections
#####################################################
# Find Static Structure Facto
##S is sf peaks with the noise removed
##Q is the corresponding q-vectors magnitude that go with the sf peaks
##Primitive vectors is the correspoinding q-vector
#####################################################
def structure_factor(VW, L, var, n_frames=10, n_start=1, 
        filters=0.05, dh=0.05,save='sf'):
    import MD.analysis.sfactor as sf
    #Find Structure Factor
    stmp,qx = sf.sfactor(VW[n_start:n_start+n_frames],L=L,l=10) 
    S,Q,primitive_vectors = sf.sort_sfpeaks(stmp,qx)
    #Plot the graph
    xlabel = '$|\\vec{q}$ $|$'
    ylabel = '$S(\\vec{q}$ $)$ '
    pyplot.plot(Q, S, linestyle='', marker='x', 
            xlabel=xlabel, ylabel=ylabel, save=save)
    #if len(QQ)>500:
    #    bars,height = sf.sf_max(QQ,qpeaks=8)
    #    db_x,db_y = sf.dbfactor(msdr=5)
    #    pyplot.plot_bar(bars, height, xlabel=xlabel, ylabel=ylabel,
    #            save=save)
    #    pyplot.plot(db_x, db_y, linestyle='--', xlabel=xlabel, ylabel=ylabel,
    #            save=save)
    #    #return q, s, bars, height, db_x, db_y
    #    return Q, S, primitive_vectors
    #filter out the noise
    Q, S, primitive_vectors = sf.sf_filter(Q, S, primitive_vectors, filters=filters)
    return Q, S, primitive_vectors
######################
# FInd the rotational motion of cube
#####################
def rotations(M,VW,L):
    Z = M.cord_auto(['Z'])
    theta, phi = single_rotation(VW,Z,L)
    x=np.arange(theta.shape[0])
    pyplot.plot2(x,theta,x,phi,label1='theta',
            label2='phi',save='rotation',showleg=True)
    return x, theta, phi
#####################################################
# Look at mixing of species of spheres
#####################################################
def species_mixing(V,W,L,n_finish=1,n_start=0,delta=100,rcut=False):
    #The total number of frames we are going to look at
    if rcut == False:
        rcut=min_particle_distance(V[-1:],W[-1:],L)+6
    print rcut
    #rcut = 19
    rcut = 20
    n_frames = (n_finish-n_start)/delta
    x = np.arange(n_start,n_finish,delta)
    s = []
    o = []
    for k in x:
        Same = 0
        Other = 0
        print k
        for i in range(V[k].shape[0]):
            Same += len(nearest_neighbors_point(V[k],V[k][i],L,rcut)[0])
            Same += len(nearest_neighbors_point(W[k],W[k][i],L,rcut)[0])
            Other += len(nearest_neighbors_point(W[k],V[k][i],L,rcut)[0])
            Other += len(nearest_neighbors_point(V[k],W[k][i],L,rcut)[0])
        s.append(float(Same)/(W[k].shape[0]+V[k].shape[0]))
        o.append(float(Other)/(V[k].shape[0]+W[k].shape[0]))
    print s
    print o
    util.pickle_dump([x,s,o],'mix.pkl')
    pyplot.plot2(x, s, x, o, label1='Same',
            label2='other', save='mixing_avg', showleg=True)
## \brief read mylog file and makes a plot of the energy
#
# \returns x coordinates of time step
# \returns y whatever value of the row you are looking for
#
# \param row the row you would like to grab data from 
def mylog(row = 2):
    #read log file
    import re
    fid = open('mylog.log','r')
    text = fid.readlines()
    fid.close()
    #loop through and pull out values we want
    x = []
    y = []
    for line in text[1:]:
        x.append(line.split()[0])
        y.append(line.split()[row])
    #make a simple plot
    label = re.sub("_"," ",text[0].split()[row])
    save = text[0].split()[row]
    pyplot.plot(x, y, xlabel='Time', ylabel=label, save=save)
    return x, y
def run_defect():
    #setup
    #print out directory
    dirname = os.getcwd().partition('/')[-1]
    print "Starting:",dirname.split('/')[-1]
    try:
        var = MD.util.get_path_variables()
    except:
        var = {'ndna':60}
    print var
    M=MD.ReadCord()
    L = M.box_length
    last = M.frames
    try:
        V = util.pickle_load('V.pkl')
        W = util.pickle_load('W.pkl')
        R = util.pickle_load('R.pkl')
        VW = util.pickle_load('VW.pkl')
    except:
        V=M.cord_auto(['V'])
        W=M.cord_auto(['W'])
        R=M.cord_auto(['R'])
        VW=M.cord_auto(['V','W'])
        VW,V,W = drift_remove_all(VW,V,W,L)
        R = drift_remove(R,L)
        util.pickle_dump(V,'V.pkl')
        util.pickle_dump(W,'W.pkl')
        util.pickle_dump(VW,'VW.pkl')
        util.pickle_dump(R,'R.pkl')
    x = range(0,last,last/5)
    #mylog()
    #plt.close()
    solid_particles_vmd(VW,V,W,L,var,skip=100)
    plt.close()
    #species_mixing(V,W,L,n_finish=last)
    #plt.close()
    #species_mixing_fcc(VW,L,n_finish=last)
    #plt.close()
    for i in x:
        #print "finding s(q)"
        structure_factor(VW, L, var, n_start=i,save='sf'+str(i))
        print "finding g(s)"
        distance_distribution(V,W,L,n_start=i)
        plt.close()
    msd(VW,L)
    plt.close()
    msd(R,L,save='msd_R')
    plt.close()
    #end_end(V,W,M,L,var)
    #find_networks(M, VW, L, var, last,delta=25)
    #plt.close()
    #sphere_rotations(M,W,L,'N')
def run_test():
    #print out directory
    dirname = os.getcwd().partition('/')[-1]
    print "Starting:",dirname.split('/')[-1]
    try:
        var = MD.util.get_path_variables()
    except:
        var = {'ndna':60}
    print var
    M=MD.ReadCord()
    Lx = M.box_length
    Ly = M.box_length_y
    Lz = M.box_length_z
    L = [Lx, Ly, Lz]
    print L
    last = M.frames
    try:
        V = util.pickle_load('V.pkl')
        W = util.pickle_load('W.pkl')
        VW = util.pickle_load('VW.pkl')
    except:
        V=M.cord_auto(['V'])
        W=M.cord_auto(['W'])
        VW=M.cord_auto(['V','W'])
        VW_index=M.get_names(['V','W'])
        VW,V,W = drift_remove_all(VW,V,W,L,VW_index)
        util.pickle_dump(V,'V.pkl')
        util.pickle_dump(W,'W.pkl')
        util.pickle_dump(VW,'VW.pkl')
    x = range(0,last,last/5)
    delta = 5
    #step,temp = mylog(row = 2)
    #plt.close()
    solid_particles_vmd(VW,V,W,L,M,skip=25)
    #solid_particles_vmd(VW[1000:],V[1000:],W[1000:],L,var,skip=10)
    #plt.close()
    #species_mixing(V,W,L,n_finish=last)
    #plt.close()
    #species_mixing_fcc(VW,L,n_finish=last)
    #plt.close()
    #end_end(V,W,M,L)
    #plt.close()
    #for i in x:
    #    #print "finding s(q)"
        #structure_factor(VW, L, var, n_start=i,save='sf'+str(i))
    #    print "finding g(s)"
    #    distance_distribution(V,W,L,n_start=i)
    #    plt.close()
    #msd(VW,L)
    #plt.close()
    #find_lifetime(M,L,x,temp,step_range=30,delta=5)
    #plt.close()
    #find_networks(M, VW, L, var, last, delta = delta)
    #plt.close()
    #sphere_rotations(M,W,L,'N')
#For multiple directories
if __name__ == '__main__':
    for f in sorted(os.listdir("./")):
        if os.path.isdir(f):
            os.chdir(f)
            run_test()
            #run_defect()
            #try:
            #    run_defect()
            #except:
            #    print "Someting Failed"
            #print '##\nfinished with:',f
            os.chdir('../')
#For single directories
if __name__ == '__main__':
    #run_debug()
    #run_all()
    run_test()
