
import numpy as np
import MD.util as util
import MD.base.points as points
import MD.plot.pyplot as pyplot
import pyplot as plt

import MD.unit.make_bcc as make
import MD.analysis.sfactor as sf
import MD.analysis.msdr as msdr
import MD.plot.pyplot as pyplot
import MD.analysis.nearest_neighbor as nn
from MD.analysis.particle_distance import min_point_distance
reload(nn)
from MD.analysis.nearest_neighbor import nearest_neighbors_point
from MD.analysis.nearest_neighbor import close_neighbors_point
from MD.analysis.nearest_neighbor import rcut_neighbors_point
from MD.plot.histogram import histogram
#####################################################
# Look at defects 
#####################################################
def find_lattice(VW,V,W,L,n_finish=1,n_start=0,delta=20,filters=0.2):
    # Identify the bcc lattice as a grid and find the recipricol lattice
    #Find Structure Factor
    #print VW.shape
    redo = True
    while redo == True:
        stmp,qx = sf.sfactor(VW[-10:-1],L=L,l=10)
        S,Q,primitive_vectors = sf.sort_sfpeaks(stmp,qx)
        print np.array(Q)
        Q, S, primitive_vectors = sf.sf_filter(Q, S, primitive_vectors,
                filters=filters, save = 'sffilter')
        a,b = MD.analysis.sfactor.recipricol(Q,primitive_vectors)
        #Find the best fit for the qlattice at a particular frame by looking
        #for the lowest value of the msdr
        x = np.arange(n_start,n_finish,delta)
        defects = np.zeros((len(x),15))
        lowest=10000
        for k in x:
            for i in range(VW.shape[1]):
                crystal, c = make.make_bcc(a[0], a[1], a[2], MD.VW[k][i], MD.L+5)
                msdr_x =  msdr.msd_r(VW[k], crystal, L)
                if lowest > msdr_x:
                    lowest = msdr_x
                    index = i
                    frame = k
        crystal, cword = make.make_bcc(a[0], a[1], a[2], MD.VW[frame][index], MD.L+5)
        print np.array(b)
        print np.array(a)
        if raw_input('Do you want to retry?[no]/yes  ')  == 'yes':
            redo = True
        else:
            redo = False
    util.pickle_dump(cword,'cword.pkl')
    util.pickle_dump(crystal,'ccrystal.pkl')
    return crystal
#filter the 'qlattice.xyz' file so that we only have the right number of atoms
def filter_lattice(crystal, Vshape, Wshape, L):
    #write projection of crystal
    #filter out parts that we dont wnat
    #and correct the parts that are wrong
    def check_type(p,basis,L,r,ver=False):
        d = int(points.dist(p,basis,L)[0])
        #x = [0,2,3,5,6,8,9,11,12,13]
        x = [0,2,3,5,6,8,9,11,12,13]
        #x = [0,2,3,5,6]
        for i in x:
            if r[i] == d:
                return 'A'
        return 'B'
    #crystalls only has the points of lattice
    C = np.zeros(crystal.shape)
    C = []
    count = 0
    ocounter = 0
    print len(crystal)
    for i in crystal:
        #if test_boundary(i, L+4):
        #make sure there aren't two that are close due to pbc
        if rcut_neighbors_point(np.array(C),i,L,rcut=10) == 0:
            C.append(i)
        else:
            print 'index removed', ocounter
        ocounter += 1
    C  = np.array(C)
    #CV = np.zeros(V[1].shape)
    #CW = np.zeros(W[1].shape)
    CV = np.zeros((Vshape,3))
    CW = np.zeros((Vshape,3))
    count_V = 0
    count_W = 0
    d = []
    for i in range(C.shape[0]):
        d.append(int(points.dist(C[i],C[10],L)[0]))
    d.sort()
    dd = points.unique(d)
    sumd = 0
    for i,j in enumerate(dd):
        print i,' ', d.count(j)
        sumd += d.count(j)
    print sumd
    d = points.unique(d)
    d.sort()
    print d
    #distances between all points
    for i in range(C.shape[0]):
        if check_type(C[i],C[0],L,d) == 'A':
            CV[count_V] = C[i]
            count_V += 1
        if check_type(C[i],C[0],L,d) == 'B':
            CW[count_W] = C[i]
            count_W += 1
    print CV.shape[0]
    fid = open('projlattice.xyz','w')
    fid.write(('%i\n')%(CV.shape[0]+CW.shape[0]))
    fid.write('Atoms\n')
    for i in range(len(CV)):
            fid.write(('%c   %f   %f   %f\n')%('A',CV[i][0],CV[i][1], CV[i][2]))
    for i in range(len(CW)):
            fid.write(('%c   %f   %f   %f\n')%('B',CW[i][0],CW[i][1], CW[i][2]))
    fid.close()
    util.pickle_dump(CV,'CV.pkl')
    util.pickle_dump(CW,'CW.pkl')
    util.pickle_dump(d,'d.pkl')
    return CV, CW, d
# find the defects in the lattice
def find_defects(CV,CW,lattice,VW,V,W,L,n_finish=1,n_start=0,delta=20,filters=0.2):
    from MD.analysis.nearest_neighbor import ws_neighbors_point
    from MD.analysis.nearest_neighbor import close_neighbors_point
    #######
    x = np.arange(n_start,n_finish,delta)
    rmin = lattice[1] / 2.0
    rmax = lattice[2] / 2.0 +1
    DW = np.zeros((len(x),V.shape[1]))
    DV = np.zeros((len(x),V.shape[1]))
    vac_count = np.zeros((len(x),1))
    int_count = np.zeros((len(x),1))
    fid = open('defects.txt','w')
    master = [[],[]]
    for index,k in enumerate(x):
        print 'frame',k
        # Identify the points on the bcc Lattice which belong to A and B type
        #lets look at one point first
        # Assign each point to its place on the lattice
        #find the closest point   
        #####################
        N = []
        N_V = []
        N_W = []
        for i in range(V.shape[1]):
            num = 0
            N =  ws_neighbors_point(V[k],CV[i],L,i,rmin=rmin,rmax=rmax)[0]
            N_V.extend(N)
            if len(N) == 1:
                num = 1
            if len(N) == 2:
                num = 2
            if len(N) == 0:
                N2 = ws_neighbors_point(W[k],CV[i],L,i,rmin=rmin,rmax=rmax)[0]
                N_W.extend(N2)
                if len(N2) ==1:
                    num = -1
            DV[index][i] = num
        ###########################
        for i in range(W.shape[1]):
            num = 0
            N =  ws_neighbors_point(W[k],CW[i],L,i+W.shape[1],rmin=rmin,rmax=rmax)[0]
            N_W.extend(N)
            if len(N) == 1:
                num = 1
            if len(N) == 2:
                num = 2
            if len(N) == 0:
                N2 = ws_neighbors_point(V[k],CW[i],L,i+W.shape[1],rmin=rmin,rmax=rmax)[0]
                N_V.extend(N2)
                if len(N2) ==1:
                    num = -1
            DW[index][i] = num
        #find the atoms that haven't been placed on the lattice yet
        IV = points.difference(range(V.shape[1]),N_V)
        IW = points.difference(range(W.shape[1]),N_W)
        ##
        print 'atoms not added list for debugging'
        print IV, IW
        for i in IV:
            #find closest lattice point
            nw, dw = close_neighbors_point(CW,V[k][i],L)
            nv, dv = close_neighbors_point(CV,V[k][i],L)
            if dw <= dv:
                #check to see if there is already an atom at that point
                if DW[index][nw] == 1 or DW[index][nw] == -1:
                    if DV[index][nv] == 0:
                        DV[index][nv] = 1
                        N_V.extend([i])
                    else:
                        DW[index][nw] = -2
                        N_V.extend([i])
                if DW[index][nw] == 0:
                        DW[index][nw] = -1
                        N_V.extend([i])
                #check to see if there is already an atom at that point
            else:
                if DV[index][nv] == 1 or DV[index][nv] == -1:
                    #if there isn't one at the other point add it
                    if DW[index][nw] == 0:
                        DW[index][nw] = -1
                        N_V.extend([i])
                    else:
                        if DV[index][nv] == 1:
                            DV[index][nv] = 2
                        if DV[index][nv] == -1:
                            DV[index][nv] = -2
                        N_V.extend([i])
                if DV[index][nv] == 0:
                    DV[index][nv] = 1
                    N_V.extend([i])
        for i in IW:
            nw, dw = close_neighbors_point(CW,W[k][i],L)
            nv, dv = close_neighbors_point(CV,W[k][i],L)
            if dv <= dw:
                if DV[index][nv] == 1 or DV[index][nv] == -1:
                    if DW[index][nw] == 0:
                        DW[index][nw] = 1
                        N_W.extend([i])
                    else:
                        DV[index][nv] = -2
                        N_W.extend([i])
                if DV[index][nv] == 0:
                    DV[index][nv] = -1
                    N_W.extend([i])
            else:
                if DW[index][nw] == 1 or DW[index][nw] == -1:
                    if DV[index][nv] == 0:
                        DV[index][nv] = -1
                        N_W.extend([i])
                    else:
                        DW[index][nw] = 2
                        N_W.extend([i])
                if DW[index][nw] == 0:
                    DW[index][nw] = 1
                    N_W.extend([i])
        #find the atoms that haven't been placed on the lattice yet
        IV = points.difference(range(V.shape[1]),N_V)
        IW = points.difference(range(W.shape[1]),N_W)
        ##
        print 'atoms not added list for debugging'
        print IV, IW
        print DW[index]
        print DV[index]
        print 'Defect list for lattice'
        #print out the vacency, substitutions
        def out_defect(A, index, fid, def_list, C=0):
            for i in range(A.shape[1]):
                if A[index][i] == 0:
                    pr =  'vacecy at '+ str(i+C)+ '\n'
                    try:
                        def_list[0].extend(i+C)
                    except:
                        def_list[0].append(i+C)
                    print pr
                    fid.write(pr)
                if A[index][i] == -1:
                    pr = 'substitution ' + str(i+C)+ '\n'
                    print pr
                    fid.write(pr)
                if A[index][i] == -2:
                    pr = 'interstitial ' + str(i + C)+ '\n'
                    try:
                        def_list[1].extend(i+C)
                    except:
                        def_list[1].append(i+C)
                    print pr
                    fid.write(pr)
                if A[index][i] == 2:
                    pr = 'interstitial ' + str(i + C)+ '\n'
                    try:
                        def_list[1].extend(i+C)
                    except:
                        def_list[1].append(i+C)
                    print pr
                    fid.write(pr)

        frame = 'Frame ' + str(k) + '\n'
        fid.write(frame)
        def_list = [[],[]]
        out_defect(DV, index, fid, def_list)
        out_defect(DW, index, fid, def_list, C = DV.shape[1])
        if len(points.difference(def_list[0], master[0])) != 0:
            vac_count[index] += len(points.difference(def_list[1],master[1]))
            master[0] = def_list[0]
        if len(points.difference(def_list[1],master[1])) != 0:
            int_count[index] += len(points.difference(def_list[1],master[1]))
            master[1] = def_list[1]

        #find the atoms that haven't been placed on the lattice yet
        IV = points.difference(range(V.shape[1]),N_V)
        IW = points.difference(range(W.shape[1]),N_W)

        # Identify the number of defects surrounding each point
        #The total number of frames we are going to look at
        # Find the number of defects in each frame
    count = 0
    substitutions = []
    vacancies = []
    intersticial = []
    def count_def(A,check):
        count = 0
        for i in A:
            if i == check:
                count +=1
        return count
    def count_ldef(A,check):
        count = 0
        for i in A:
            if i < check:
                count +=1
        return count
    def count_adef(A,check):
        count = 0
        for i in A:
            if abs(i) == check:
                count +=1
        return count
    for k in range(DW.shape[0]):
        #find the points that are nearest neighbor that are different
        substitutions.append(count_ldef(DW[k],0)+count_ldef(DV[k],0))
        vacancies.append(count_def(DW[k],0)+count_def(DV[k],0))
        intersticial.append(count_adef(DW[k],2.0)+count_adef(DV[k],2.0))
    print substitutions
    print vacancies
    print intersticial
    pyplot.plot3(x, substitutions, x, vacancies, x, intersticial, save='defects_per_frame')
    pyplot.plot(x, vac_count, save='defect_vac_diffusion_count')
    pyplot.plot(x, int_count, save='defect_int_diffusion_count')
    util.pickle_dump(DV,'DV.pkl')
    util.pickle_dump(DW,'DW.pkl')
    return DV, DW
    #find the vacancies
#write the vacancey into an xyz file
def write_vac(DV,DW,CV,CW,delta=5):
    def find_vac(A,check):
        vac = []
        for i,j in enumerate(A):
            if j == check:
                vac.append(i)
        return vac
    vacA = []
    vacB = []
    for k in range(DW.shape[0]):
        vacA.append(find_vac(DV[k],0))
        vacB.append(find_vac(DW[k],0))

    fid = open('defect.xyz','w')
    for k in range(DW.shape[0]):
        for i in range(delta):
            fid.write(('%i\n')%(2*DV.shape[1]))
            fid.write('Atoms\n')
            for i in range(DV.shape[1]):
                if i in vacA[k]:
                    fid.write(('A %.2f %.2f %.2f\n')%(CV[i][0],CV[i][1],CV[i][2]))
                else:
                    fid.write('A 30 30 30\n')

            for i in range(DW.shape[1]):
                if i in vacB[k]:
                    fid.write(('B %.2f %.2f %.2f\n')%(CW[i][0],CW[i][1],CW[i][2]))
                else:
                    fid.write('B 30 30 30\n')
    fid.close()
#find the msd of the vacancy
def vac_msd(DV,DW,CV,CW,L):
    vacancies = np.zeros((DV.shape[0],1,3))
    for k in range(len(DW)):
        print k
        #find the points that are nearest neighbor that are different
        index = np.where(DW[k] == 0)[0]
        if len(index) > 0:
            if len(index) > 1:
                index = index[1]
            vacancies[k][0]  = CW[index]
        else:
            index = np.where(DV[k] == 0)[0]
            if len(index) > 1:
                index = index[1]
            vacancies[k][0] = CV[index]
    from MD.analysis.msd import diff
    #Find the msd of the system
    x, msd = diff(vacancies, L)
    pyplot.plot(x,msd,xlabel='Time',ylabel='msd',save='MSD_vacancey')
#find what sort of defect the vacaney moves too
#find what sort of GNP moves to where the vacancy was
#count up these numbers. 
def vac_move_to(DV,DW):
    vacancies = np.zeros((DV.shape[0],1))
    for k in range(len(DW)):
        #find the points that are nearest neighbor that are different
        index = np.where(DW[k] == 0)[0]
        if len(index) > 0:
            if len(index) > 1:
                index = index[1]
            vacancies[k]  = index
        else:
            index = np.where(DV[k] == 0)[0]
            if len(index) > 1:
                index = index[1]
            vacancies[k] = index + DW.shape[1]
    #now that we have the indexes lets go back through and pcik out where they
    #came from
    def check(vac, DW, DV):
        if vac > DW.shape[0]:
            return DV[vac-DW.shape[0]]
        else:
            return DW[vac]
    last = []
    new = []
    for k in range(1,vacancies.shape[0]):
        if vacancies[k] == vacancies[k-1]:
            last.append(0)
            new.append(0)
        else:
            last.append(check(vacancies[k][0],DW[k-1],DV[k-1]))
            new.append(check(vacancies[k-1][0],DW[k],DV[k]))
    count = 0
    count_def = 0
    print 'GNP that moved was'
    for i in last:
        if i == 1.0:
            count += 1
        if i == -1.0:
            count_def += 1
    print 'not a defect'
    print count
    print 'a substitution'
    print count_def
    print 'filled vacancy with'
    count = 0
    count_def = 0
    for i in new:
        if i == 1.0:
            count += 1
        if i == -1.0:
            count_def += 1
    print 'not a defect'
    print count
    print 'a substitution'
    print count_def
    count = 0
    count_def = 0
    print 'last vacancy filled with'
    for i in range(len(new)):
        if new[i] == 1.0:
            if new[i-1] == 0:
                count += 1
        if new[i] == -1.0:
            if new[i-1] == 0:
                count_def += 1
    print 'not a defect'
    print count
    print 'a substitution'
    print count_def
    count = 0
    count_def = 0
    print 'First GNP that moved was'
    for i in range(len(last)):
        if last[i] == 1.0:
            if last[i-1] == 0:
                count += 1
        if last[i] == -1.0:
            if last[i-1] == 0:
                count_def += 1
    print 'not defect'
    print count
    print 'a substitution'
    print count_def

    x = range(len(new))
    #Find the msd of the system
    pyplot.plot(x,new,xlabel='Time',ylabel='vac',save='vacancey_to')
    pyplot.plot(x,last,xlabel='Time',ylabel='vac',save='vacancey_from')

def vac_move_to(DV,DW):
    vacancies = np.zeros((DV.shape[0],1))
    #find the vacancies in the simulations
    for k in range(len(DW)):
        #find the points that are nearest neighbor that are different
        index = np.where(DW[k] == 0)[0]
        if len(index) > 0:
            if len(index) > 1:
                index = index[1]
            vacancies[k]  = index
        else:
            index = np.where(DV[k] == 0)[0]
            if len(index) > 1:
                index = index[1]
            vacancies[k] = index + DW.shape[1]
    #now that we have the indexes lets go back through and pick out where they
    #came from
    def check(vac, DW, DV):
        if vac > DW.shape[0]:
            return DV[vac-DW.shape[0]]
        else:
            return DW[vac]
    last = []
    new = []
    for k in range(1,vacancies.shape[0]):
        if vacancies[k] == vacancies[k-1]:
            last.append(0)
            new.append(0)
        else:
            last.append(check(vacancies[k][0],DW[k-1],DV[k-1]))
            new.append(check(vacancies[k-1][0],DW[k],DV[k]))
    count = 0
    count_def = 0
    print 'GNP that moved was'
    for i in last:
        if i == 1.0:
            count += 1
        if i == -1.0:
            count_def += 1
    print 'not a defect'
    print count
    print 'a substitution'
    print count_def
    print 'filled vacancy with'
    count = 0
    count_def = 0
    for i in new:
        if i == 1.0:
            count += 1
        if i == -1.0:
            count_def += 1
    print 'not a defect'
    print count
    print 'a substitution'
    print count_def
    count = 0
    count_def = 0
    print 'last vacancy filled with'
    for i in range(len(new)):
        if new[i] == 1.0:
            if new[i-1] == 0:
                count += 1
        if new[i] == -1.0:
            if new[i-1] == 0:
                count_def += 1
    print 'not a defect'
    print count
    print 'a substitution'
    print count_def
    count = 0
    count_def = 0
    print 'First GNP that moved was'
    for i in range(len(last)):
        if last[i] == 1.0:
            if last[i-1] == 0:
                count += 1
        if last[i] == -1.0:
            if last[i-1] == 0:
                count_def += 1
    print 'not defect'
    print count
    print 'a substitution'
    print count_def

    x = range(len(new))
    #Find the msd of the system
    pyplot.plot(x,new,xlabel='Time',ylabel='vac',save='vacancey_to')
    pyplot.plot(x,last,xlabel='Time',ylabel='vac',save='vacancey_from')
def vac_surround(DV,DW,CV,CW,L):
    vacancies = np.zeros((DV.shape[0],1))
    #find the vacancies in the simulations
    for k in range(len(DW)):
        #find the points that are nearest neighbor that are different
        index = np.where(DW[k] == 0)[0]
        if len(index) > 0:
            if len(index) > 1:
                print index
                index = index[0]
            vacancies[k]  = index
        else:
            index = np.where(DV[k] == 0)[0]
            if len(index) > 1:
                index = index[0]
            vacancies[k] = index + DW.shape[1]
    #now that we have the indexes lets go back through and pick out where they
    #came from
    def check(vac, DW, DV):
        if vac > DW.shape[0]:
            return DV[vac-DW.shape[0]]
        else:
            return DW[vac]
    # find lattice point
    def find_lattice(vac, CW, CV):
        vac = int(vac[0])
        if vac > CW.shape[0]:
            return CV[vac-CW.shape[0]]
        else:
            return CW[vac]
    #find the index of the neighbors of the vacancey
    def find_neighbors(index, CW, CV, L, cut = 17):
        point = find_lattice(index,CW,CV)
        V_neighbors = []
        W_neighbors = []
        for i,j in enumerate(CV):
            if points.dist(j,point,L)[0] < cut:
                if points.dist(j,point,L)[0] > 1:
                    V_neighbors.append(i)
        for i,j in enumerate(CW):
            if points.dist(j,point,L)[0] < cut:
                if points.dist(j,point,L)[0] > 1:
                    W_neighbors.append(i)
        return V_neighbors, W_neighbors

    #Find out if the neighbors are substitutions or correctly placed
    def find_subs(V, W, DW, DV):
        subs = []
        for i in V:
            subs.append(DV[i])
        for i in W:
            subs.append(DW[i])
        return subs

    #find the number of substitutions at each step surrounding the vacancy
    subs = []
    for k in range(len(vacancies)):
        V_neigh, W_neigh = find_neighbors(vacancies[k], CW, CV, L)
        sub  = find_subs(V_neigh, W_neigh, DW[k], DV[k])
        count = 0
        for i in sub:
            if i > 0:
                count+=1
        subs.append(count)


    #find the number of substitutions surrounding a point
    #find the time that the vacancy remains there
    time = 1
    vac = []
    for k in range(2,vacancies.shape[0]):
        if vacancies[k] == vacancies[k-1]:
            time += 1
        else:
            vac.append([subs[k-1],time,k-1])
            time = 1

    print vac
    #lets make the data accessable. How about trying a histogram
    #first sort by numer of substittuioins
    d0 = []
    d1 = []
    d2 = []
    d3 = []
    for i in vac:
        if i[1] > 1:
            if i[0] == 3:
                d3.append(time)
            if i[0] == 2:
                d2.append(time)
            if i[0] == 1:
                d1.append(time)
            if i[0] == 0:
                d0.append(time)
    print d2

    hist0,x0,max0=histogram(d0,20)
    hist1,x1,max1=histogram(d1,20)
    hist2,x2,max2=histogram(d2,20)
    hist3,x3,max3=histogram(d3,20)
    print max0
    print max1
    print max2
    print max3

    pyplot.plot_bar(x0,hist0,save='substitutions0')
    plt.close()
    pyplot.plot_bar(x1,hist1,save='substitutions1')
    plt.close()
    pyplot.plot_bar(x2,hist2,save='substitutions2')
    plt.close()
    pyplot.plot_bar(x3,hist3,save='substitutions3')
    plt.close()

def vac_find():
    DV = util.pickle_load('DV.pkl')
    DW = util.pickle_load('DW.pkl')
    vac_move_to(DV,DW)

def vac_near():
    import MD
    CV = util.pickle_load('CV.pkl')
    CW = util.pickle_load('CW.pkl')
    DV = util.pickle_load('DV.pkl')
    DW = util.pickle_load('DW.pkl')
    vac_surround(DV,DW,CV,CW,MD.L)

if __name__ == '__main__':
    vac_near()
#if __name__ == '__main__':
#    #run_debug()
#    #run_all()
#    import MD
#    from MD.dna_scripts.square import drift_remove_all
#    print 'MD.L is '
#    print MD.L
#    MD.V = MD.M.cord_auto(['V'])
#    MD.W = MD.M.cord_auto(['W'])
#    MD.VW = MD.M.cord_auto(['V','W'])
#    MD.VW, MD.V, MD.W = drift_remove_all(MD.VW[1:],MD.V[1:],MD.W[1:],MD.L)
#    try:
#        crystal = util.pickle_load('ccrystal.pkl')
#        cword = util.pickle_load('cword.pkl')
#    except:
#        crystal = find_lattice(MD.VW,MD.V,MD.W,MD.L,n_finish=MD.last-1,n_start=MD.last-21,delta=5)
#    try:
#        CV = util.pickle_load('CV.pkl')
#        CW = util.pickle_load('CW.pkl')
#        d = util.pickle_load('d.pkl')
#    except:
#        CV, CW, d = filter_lattice(crystal, MD.V.shape[1], MD.W.shape[1], MD.L)
#    try:
#        DV = util.pickle_load('DV.pkl')
#        DW = util.pickle_load('DW.pkl')
#    except:
#        DV, DW = find_defects(CV,CW,d,MD.VW,MD.V,MD.W,MD.L,n_finish=MD.last-1,n_start=0,delta=1)
#    #vac_move_to(DV,DW)
#    #write_vac(DV,DW,CV,CW,delta=1)

#    #vac_msd(DV,DW,CV,CW,MD.L)


